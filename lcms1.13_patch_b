diff -r -U3 lcms-1.13/include/lcms.h lcms-1.13_vcgt/include/lcms.h
--- lcms-1.13/include/lcms.h	2004-05-19 11:09:56.000000000 +0200
+++ lcms-1.13_vcgt/include/lcms.h	2005-01-04 23:11:29.000000000 +0100
@@ -130,10 +130,20 @@
 #   include <unistd.h>
 #endif
 
+/* the type conflicts might occur when linking with other libraries like X11 */
+/* Stefan Döhla <stefan AT doehla DOT de> */
+#ifndef BYTE_CONFLICT
 typedef unsigned char BYTE, *LPBYTE; 
+#endif
+#ifndef WORD_CONFLICT
 typedef unsigned short WORD, *LPWORD;
+#endif
+#ifndef DWORD_CONFLICT
 typedef unsigned int DWORD, *LPDWORD;
+#endif
+#ifndef BOOL_CONFLICT
 typedef int BOOL;
+#endif
 typedef char *LPSTR;
 typedef void *LPVOID;
 typedef void* LCMSHANDLE;
@@ -213,6 +223,9 @@
 #define icSiglutAtoBType                ((icTagTypeSignature) 0x6d414220L)  // mAB 
 #define icSiglutBtoAType                ((icTagTypeSignature) 0x6d424120L)  // mBA 
 
+/* Stefan Döhla <stefan AT doehla DOT de> */
+#define icSigVideoCardGammaTag          ((icTagTypeSignature) 0x76636774L)  //'vcgt'
+
 
 typedef struct {
     icUInt8Number       gridPoints[16]; // Number of grid points in each dimension.  
@@ -840,6 +853,11 @@
 LCMSAPI BOOL          LCMSEXPORT cmsTakeColorants(LPcmsCIEXYZTRIPLE Dest, cmsHPROFILE hProfile);
 LCMSAPI DWORD         LCMSEXPORT cmsTakeHeaderFlags(cmsHPROFILE hProfile);
 
+/* vcgt-tag for display calibration */
+/* Stefan Döhla <stefan AT doehla DOT de> */
+LCMSAPI BOOL          LCMSEXPORT cmsTakeVideoCardGammaTable(cmsHPROFILE hProfile, LPGAMMATABLE * rVideoCardGamma,
+                                            LPGAMMATABLE * gVideoCardGamma, LPGAMMATABLE * bVideoCardGamma);
+
 LCMSAPI void          LCMSEXPORT cmsSetLanguage(int LanguageCode, int CountryCode);
 LCMSAPI const char*   LCMSEXPORT cmsTakeProductName(cmsHPROFILE hProfile);
 LCMSAPI const char*   LCMSEXPORT cmsTakeProductDesc(cmsHPROFILE hProfile);
diff -r -U3 lcms-1.13/NEWS lcms-1.13_vcgt/NEWS
--- lcms-1.13/NEWS	2004-05-19 11:09:55.000000000 +0200
+++ lcms-1.13_vcgt/NEWS	2005-01-04 23:22:50.000000000 +0100
@@ -1,3 +1,8 @@
+patch added by Stefan Doehla:
+vcgt-Tag parsing by LCMS (propably needed by xcalib)
+
+
+
 
  New in ver 1.13
  ===============
diff -r -U3 lcms-1.13/src/cmsio1.c lcms-1.13_vcgt/src/cmsio1.c
--- lcms-1.13/src/cmsio1.c	2004-05-19 11:09:56.000000000 +0200
+++ lcms-1.13_vcgt/src/cmsio1.c	2005-02-26 19:34:00.000000000 +0100
@@ -46,6 +46,12 @@
 BOOL          LCMSEXPORT cmsTakeMediaBlackPoint(LPcmsCIEXYZ Dest, cmsHPROFILE hProfile);
 BOOL          LCMSEXPORT cmsTakeIluminant(LPcmsCIEXYZ Dest, cmsHPROFILE hProfile);
 BOOL          LCMSEXPORT cmsTakeColorants(LPcmsCIEXYZTRIPLE Dest, cmsHPROFILE hProfile);
+
+/* prototype for vcgt-parsing */
+/* Stefan Doehla <stefan AT doehla DOT de> */
+BOOL          LCMSEXPORT cmsTakeVideoCardGammaTable(cmsHPROFILE hProfile, LPGAMMATABLE * rVideoCardGamma,
+                                           LPGAMMATABLE * gVideoCardGamma, LPGAMMATABLE * bVideoCardGamma);
+
 BOOL          LCMSEXPORT cmsIsTag(cmsHPROFILE hProfile, icTagSignature sig);
 
 const char*   LCMSEXPORT cmsTakeManufacturer(cmsHPROFILE hProfile);
@@ -1892,6 +1898,130 @@
 
 }
 
+/* Video Card Gamma Tag/Table/Type */
+/* Stefan Doehla <stefan AT doehla DOT de> */
+BOOL LCMSEXPORT cmsTakeVideoCardGammaTable(cmsHPROFILE hProfile, LPGAMMATABLE * rVideoCardGamma,
+    LPGAMMATABLE * gVideoCardGamma, LPGAMMATABLE * bVideoCardGamma)
+{
+  LPLCMSICCPROFILE    Icc = (LPLCMSICCPROFILE) (LPSTR) hProfile;
+  icTagBase           Base;
+  size_t              offset;
+  int                 n;
+  int                 i;
+  unsigned int        nEntries;
+
+  /* gamma tables which contain entire vcg-information */
+  LPGAMMATABLE        vcgR, vcgG, vcgB;
+  LPGAMMATABLE        systemGamma;
+  LPGAMMATABLE        linearGamma;
+  LPGAMMATABLE        rGammaTable, gGammaTable, bGammaTable;
+
+  icUInt32Number        VideoCardGammaType;
+  /* for vcg-formula */
+  icS15Fixed16Number    r_gamma, r_min, r_max;
+  icS15Fixed16Number    g_gamma, g_min, g_max;
+  icS15Fixed16Number    b_gamma, b_min, b_max;
+  /* for vcg-table */
+  icUInt16Number  channels, entryCount, entrySize;
+
+  /* let's check whether gamma-tables have same size */
+  if((*rVideoCardGamma)->nEntries == (*gVideoCardGamma)->nEntries &&
+      (*rVideoCardGamma)->nEntries == (*bVideoCardGamma)->nEntries)
+    nEntries = (*rVideoCardGamma)->nEntries;
+  else
+  {
+    cmsSignalError(LCMS_ERRC_ABORTED, "invalid passed gamma tables");
+    return FALSE;
+  }
+
+  n = SearchTag(Icc, icSigVideoCardGammaTag);
+  if (n < 0) {
+   cmsSignalError(LCMS_ERRC_ABORTED, "Tag not found");
+   return FALSE;
+  }
+
+  offset = Icc -> TagOffsets[n];
+
+  if (Icc -> Seek(Icc->stream, offset))
+    return FALSE;
+
+  Icc -> Read(&Base, sizeof(icTagBase), 1, Icc -> stream);
+  Icc -> Read(&VideoCardGammaType, sizeof(VideoCardGammaType), 1, Icc -> stream);
+  AdjustEndianess32((LPBYTE) &VideoCardGammaType);
+
+  /* 10bit should be sufficient for internal gamma calculation */
+#ifdef WIN32
+  systemGamma = cmsBuildGamma(1024, 0.45454544);
+#elif MACOS
+  systemGamma = cmsBuildGamma(1024, 0,55555555);
+#else /* UNIX */
+  systemGamma = cmsBuildGamma(1024, 0.45);
+#endif
+  linearGamma = cmsBuildGamma(1024, 1.00);
+
+  switch ((int)VideoCardGammaType) {
+    default:
+    case 1: //formula
+      Icc -> Read(&r_gamma, sizeof(r_gamma), 1, Icc -> stream);
+      Icc -> Read(&r_min,   sizeof(r_gamma), 1, Icc -> stream);
+      Icc -> Read(&r_max,   sizeof(r_gamma), 1, Icc -> stream);
+      Icc -> Read(&g_gamma, sizeof(g_gamma), 1, Icc -> stream);
+      Icc -> Read(&g_min,   sizeof(g_gamma), 1, Icc -> stream);
+      Icc -> Read(&g_max,   sizeof(g_gamma), 1, Icc -> stream);
+      Icc -> Read(&b_gamma, sizeof(b_gamma), 1, Icc -> stream);
+      Icc -> Read(&b_min,   sizeof(b_gamma), 1, Icc -> stream);
+      Icc -> Read(&b_max,   sizeof(b_gamma), 1, Icc -> stream);
+
+      vcgR = cmsBuildGamma(1024, Convert15Fixed16(r_gamma));
+      vcgG = cmsBuildGamma(1024, Convert15Fixed16(g_gamma));
+      vcgB = cmsBuildGamma(1024, Convert15Fixed16(b_gamma));
+      
+      rGammaTable = cmsJoinGammaEx(vcgR, systemGamma, nEntries);
+      gGammaTable = cmsJoinGammaEx(vcgG, systemGamma, nEntries);
+      bGammaTable = cmsJoinGammaEx(vcgB, systemGamma, nEntries);
+
+      break;
+    case 0: // table
+      Icc -> Read(&channels, sizeof(icUInt16Number), 1, Icc -> stream);
+      AdjustEndianess16((LPBYTE) &channels);
+      Icc -> Read(&entryCount, sizeof(icUInt16Number), 1, Icc -> stream);
+      AdjustEndianess16((LPBYTE) &entryCount);
+      Icc -> Read(&entrySize, sizeof(icUInt16Number), 1, Icc -> stream);
+      AdjustEndianess16((LPBYTE) &entrySize);
+      vcgR = cmsAllocGamma(entryCount);
+      vcgG = cmsAllocGamma(entryCount);
+      vcgB = cmsAllocGamma(entryCount);
+      for(i=0; i<entryCount; i++) {
+          Icc -> Read(&(vcgR->GammaTable[i]), entrySize, 1, Icc -> stream);
+          if(entrySize == 1)
+            vcgR->GammaTable[i] *= 0xff;
+      }
+      for(i=0; i<entryCount; i++) {
+          Icc -> Read(&(vcgG->GammaTable[i]), entrySize, 1, Icc -> stream);
+          if(entrySize == 1)
+            vcgG->GammaTable[i] *= 0xff;
+      }
+      for(i=0; i<entryCount; i++) {
+          Icc -> Read(&(vcgB->GammaTable[i]), entrySize, 1, Icc -> stream);
+          if(entrySize == 1)
+            vcgB->GammaTable[i] *= 0xff;
+      }
+      AdjustEndianessArray16(vcgR->GammaTable, entryCount);
+      AdjustEndianessArray16(vcgG->GammaTable, entryCount);
+      AdjustEndianessArray16(vcgB->GammaTable, entryCount);
+
+      rGammaTable = cmsJoinGammaEx(vcgR, linearGamma, nEntries);
+      gGammaTable = cmsJoinGammaEx(vcgG, linearGamma, nEntries);
+      bGammaTable = cmsJoinGammaEx(vcgB, linearGamma, nEntries);
+      break;
+  }
+  *rVideoCardGamma=rGammaTable;
+  *gVideoCardGamma=gGammaTable;
+  *bVideoCardGamma=bGammaTable;
+  
+  return TRUE;
+}
+
 
 // Always return a suitable matrix
 
